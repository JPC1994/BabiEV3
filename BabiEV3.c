#pragma config(Sensor, S3,     Sound,          sensorSoundDB)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Cooper Leong (20004395) & Rueban Rasaselvan (20008220)
*/

#define MAX_VAL 50
#define PENALTY 5
#define SOUND_MAX_IN 40

//prototype function declarations
void plotBar(int reading, int xOffset, int yOffset);
void updateBar(int knockOff, int xOffset, int yOffset);
void rand_Drive();
void drive(int procedure);
void escape();
void eat(int &hunger,bool &feeding,int xH_Offset,int yH_Offset);

//tasks
task checkSensors();

//global variable declarations
int light_level=0;
int sound_level=0;
int bot_distance=0;
int colour=0;
int touched=0;

task main()
{
	//variable declarations
	//ints
	int fatigue=50;						//energy level of bot
	int hunger=50;						//hunger level of bot
	int xE_Offset=0;					//x direction offset to draw fatigue bar
	int yE_Offset=105;				//y direction offset to draw fatigue bar
	int xH_Offset=0;					//x direction offset to draw hunger bar
	int yH_Offset=75;					//y direction offset to draw hunger bar
	int timer=0;							//incremenal timer to update hunger and fatigue values
	int f;										//used in for loop to update fatigue bar

	//booleans
	bool feeding=false;				//stops hunger timer while bot is eating
	bool sleeping=false;			//stops fatigue timer while bot is sleeping
	bool fedOnce=false;				//checks if bot has eaten for the first time

	//floats
	float combStat=150;				//sets LED color based on overall state of bot

	//declaration of sensors
	SensorType[S2] = sensorEV3_Color;
	SensorType[S3] = sensorSoundDB;
	SensorType[S1] = sensorEV3_Touch;
	SensorType[S4] = sensorEV3_Ultrasonic;
	resetBumpedValue(S1);

	//start checking sensors
	startTask(checkSensors);

	while(true){
		eraseDisplay();
		//Initialize hunger and fatigue bars
		//update hunger and fatigue bars
		displayTextLine(1,"Fatigue :");
		displayTextLine(5,"Hunger  :");
		plotBar(fatigue,xE_Offset,yE_Offset);
		plotBar(hunger,xH_Offset,yH_Offset);
		//increment timer by 1 every 1 second
		timer++;

		//every 2 seconds subtract 1/50 from hunger
		if((timer%1)==0&&hunger>0&&feeding==false){
			hunger-=PENALTY;
			updateBar(hunger,xH_Offset,yH_Offset);
		}
		//every 4 seconds subtract 1/50 from fatigue
		if(timer==2&&fatigue>0&&sleeping==false){
			fatigue-=PENALTY;
			updateBar(fatigue,xE_Offset,yE_Offset);
			timer=0;
		}
		//bot increases hunger meter when over green
		if (hunger<=0&&fedOnce==true){	//second feeding, bot doesnt stop
			displayTextLine(7,"I'm hungry");
			if (colour==colorGreen){
			eat(hunger,feeding,xH_Offset,yH_Offset);					//increases value of hunger meter and bar length
			}
		}
		else if (hunger<=0&&fedOnce==false){						//first feeding, bot must be brought to food
			while(true){																	//stops all other processes and waits to be fed
				setMotorSpeed(motorB,0);
				setMotorSpeed(motorC,0);
				if (colour==colorGreen){										//checks for green tile to start feeding
					eat(hunger,feeding,xH_Offset,yH_Offset);	//increases value of hunger and updates bar
					break;
				}
			}
			//plotImage(meat,10,75);											//shows visual representation of low hunger
			fedOnce=true;																	//updates fedOnce to make the bot keep running when hungry
		}

		if (fatigue<=0){																//when fatigue reaches zero, the bot will turn off all lights and stop moving to simulate passing out
			//plotImage(moon,130,75);											//visually represents the need for sleep
			setMotorSpeed(motorB,0);
			setMotorSpeed(motorC,0);
			setLEDColor(ledOff);													//turn off LED
			displayTextLine(7,"Im tired");								//tells user bot is low on energy
			sleep(3000);																	//bot stops moving and checking for sensors for 3 seconds
			fatigue+=20;																	//gives bot 20 fatigue points to allow searching for red tile again
			plotBar(fatigue,xE_Offset,yE_Offset); 				//increases fatigue bar by 20
		}
		else if (fatigue<50&&colour == colorRed){
			setMotorSpeed(motorB,0);											//stops bot to continue sensing red until required fatigue value
			setMotorSpeed(motorC,0);
			for (f=fatigue;f<MAX_VAL;f++){								//takes current fatigue value into account to prevent
				sleeping=true;															//stops bot from decreasing fatigue value while sleeping
				fatigue+=1;																	//increases fatigue by 1 point every loop
				plotBar(fatigue,xE_Offset,yE_Offset);				//updates length of fatigue bar
				wait1Msec(1);
			}
			sleeping=false;																//restarts timer to decrease energy value
		}
		rand_Drive();																					//generate a set of 8 moves for robot to execute
		//warn user when bot state drop below 100%
		if (combStat>100){
			setLEDColor(ledGreenFlash);
		}
		//warn user when bot state drop below 66.6%
		else if (combStat<100&&combStat>50){
			setLEDColor(ledOrangeFlash);
		}
		//warn user when bot state drop below 33.3%
		else if(combStat<50){
			setLEDColor(ledRedFlash);
		}
		//update combined stats
		combStat=(hunger+fatigue)/2;
		wait1Msec(1);

	}
	wait1Msec(10000);
}
//end main

task checkSensors(){
	bool bump=false;
	bool listening=false;
	while(true){														//constantly check sensors
		light_level = SensorValue[S2];				//check light level the bot is over
		sound_level = SensorValue[Sound];			//check ambient sound level
		bot_distance= getUSDistance(S4);			//check the distance of the bot to the furthest obstacle
		colour = getColorName(S2);						//check colour the bot is on
		touched=getBumpedValue(S1);						//check if the bot was bumped
		bump=getTouchValue(S1);								//check is the touch sensor is being activated
		if (bump==1){
			escape();														//if the touch sensor is activated, back up from obstacle
		}
		if (sound_level > SOUND_MAX_IN && listening == true){				// second instance of loud sound
			displayBigTextLine(7, "Shhhhhhhhhhhhhh");
			wait1Msec(2000);
		}
		//first instance of loud sound
		else if (sound_level > SOUND_MAX_IN&&listening==false)
		{
			escape();																						//reverse and turn away from sound
			listening=true;
		}
		displayTextLine(11,"colour %d",colour);
		displayTextLine(13,"sound %d",sound_level);
		displayTextLine(14,"distance %d",bot_distance);
		displayTextLine(15,"Bumped %d",touched);
		wait1Msec(1);
	}
}

void plotBar(int reading, int xOffset, int yOffset){
	int i;
	int j;
	for (i=0;i<reading;i++)												//draw bar up to state value
	{
		for(j=0;j<3;j++){														//increments position of pixel by 1
			setPixel(i + xOffset, yOffset-j);					//draw individual pixels for each bar
		}
		wait1Msec(2);
	}
}

void updateBar(int knockOff, int xOffset, int yOffset){
	int i;
	int j;
	for (i=150;i>knockOff;i--)
	{
		for(j=0;j<3;j++){														//repeats pixel removal at same x value for
			clearPixel(i + xOffset, yOffset-j);				//deletes pixels from far end of bar
		}
		wait1Msec(2);
	}
}

//creates an array of 8 random moves for the bot to execute per loop
void rand_Drive(){
	int i;
	int moves[8];															//empty array of 8 moves
	/*for(i=0;i<8;i++){
		moves[i]=-1;
		wait1Msec(1);
	}*/
	for(i=0;i<8;i++){
		moves[i]=random(5)+1;										//populates each element of the array with a random integer from 1 to 6
	}
	for (i=0;i<8;i++){
		drive(moves[i]);												//executes each move from the array
		wait1Msec(100);
	}
	/*setMotorSpeed(motorB,0);
	setMotorSpeed(motorC,0);*/
	wait1Msec(1);
}

void drive(int procedure){
	int speed=70; 														// base speed
	int desiredDistance = 20;									// desired distance
	int error;																// distance error
	float K = 3;															// distance control gain
	int inputSpeed;														// controlled speed
	if(touched==0){														//check for if bot has been hit for the first time
		inputSpeed=random(30)+30;								//random speed from 30 to 60
	}
	else if (touched>=1){											//once bot has been hit before, turn on ultrasonic sensor
		if (bot_distance<=desiredDistance){
			escape();
			inputSpeed=speed;
		}
		else if (bot_distance<60){
			error = bot_distance - desiredDistance;

			// new input speed
			inputSpeed = K*error;

			// limit input speed
			if (inputSpeed > speed)
			{
				inputSpeed = speed;
			}
			else if (inputSpeed < -speed)
			{
				inputSpeed = -speed;
			}
		}
		else {																	//if bot is below desired distance, set input speed to base speed
			inputSpeed=speed;
		}
	}
	displayTextLine(10,"Speed %d",inputSpeed);
	switch (procedure) {
		case 1:  setMotorSpeed(motorB,inputSpeed);		//forward
			setMotorSpeed(motorC,inputSpeed);
			break;
		case 2:  setMotorSpeed(motorB,inputSpeed);		//forward
			setMotorSpeed(motorC,inputSpeed);
			break;
		case 3:  setMotorSpeed(motorB,-inputSpeed);		//hard right turn
			setMotorSpeed(motorC,inputSpeed);
			break;
		case 4:  setMotorSpeed(motorB,inputSpeed);		//hard left turn
			setMotorSpeed(motorC,-inputSpeed);
			break;
		case 5:  setMotorSpeed(motorB,inputSpeed);		//gradual left turn
			setMotorSpeed(motorC,inputSpeed*0.25);
			break;
		case 6:  setMotorSpeed(motorB,inputSpeed*0.25);	//gradual right turn
			setMotorSpeed(motorC,inputSpeed);
			break;
	}
	if (procedure==1||procedure==2){	//for straightaways, move longer
		wait1Msec(500);
	}
	else{									//for turns, turn less to stabilize movement
		wait1Msec(180);
	}
}

void escape(){
	displayTextLine(8,"escape");
	int rand=random(2);												//choose a random number from 0 to 2
	if (rand==0){															//back up
		setMotorSpeed(motorB,-75);
		setMotorSpeed(motorC,-75);
		wait1Msec(1000);
		setMotorSpeed(motorB,40);
		setMotorSpeed(motorC,-40);
		wait1Msec(180);
		setMotorSpeed(motorB,0);
		setMotorSpeed(motorC,0);
		wait1Msec(10);
	}
	else if(rand==1){													//back up to the left
		setMotorSpeed(motorB,-75);
		setMotorSpeed(motorC,-10);
		wait1Msec(1000);
		setMotorSpeed(motorB,0);
		setMotorSpeed(motorC,0);
		wait1Msec(10);
	}
	else{																			//back up to the right
		setMotorSpeed(motorB,-10);
		setMotorSpeed(motorC,-75);
		wait1Msec(1000);
		setMotorSpeed(motorB,0);
		setMotorSpeed(motorC,0);
		wait1Msec(10);
	}
}

void eat(int &hunger,bool &feeding,int xH_Offset,int yH_Offset){
	int h;
	setMotorSpeed(motorB,0);				//stop motors while bot is eating
	setMotorSpeed(motorC,0);
	for (h=hunger;h<MAX_VAL;h++){
		feeding=true;						//sets feeding to true to stop timer from decreasing hunger value in main
		hunger+=1;							//increment hunger up by one from current value to max value
		plotBar(hunger,xH_Offset,yH_Offset);	//update visual hunger bar for every increment of hunger
	}
	feeding=false;							//resets boolean to allow hunger to tick down
	wait1Msec(10);
}
